---
title: "Data prep"
output: html_notebook
---

# Purpose

Prepare results from the KCHD 2024 Mental Health Survey for analysis.

# Set up environment and import data

```{r message=FALSE}
library(tidyverse)
library(readxl)
library(kcData)
library(sf)
```

```{r}
source("fn.R")
```

Import raw survey results from ETC.

```{r}
mhsurv <- read_excel("../data/1-source/KC Health_raw data_Mental Health Survey Results 2024.xls")
```

Import codebook.

```{r}
sh <- excel_sheets("../data/1-source/mhs-codebook.xlsx")
cb <- lapply(sh, \(x) read_excel(
  "../data/1-source/mhs-codebook.xlsx",
  sheet = x
))
names(cb) <- sh
```

Import HOI regions.

```{r}
hoi_regions <- st_read("../data/1-source/hoi_regions.shp", quiet = TRUE)
```

# Prep data

Rename variables.

```{r}
colnames(mhsurv) <- cb$key$var2[cb$key$in_source]
```

## Validate survey data

### `id`

Validate `id`.

```{r}
sum(duplicated(mhsurv$id))
```

Check if `id` & `id2` are identical.

```{r}
identical(mhsurv$id, mhsurv$id2)
```

### Demographics

Missing or invalid race/ethnicity values.

```{r}
mhsurv |>
  filter(if_all(re01:re08, ~ !.x %in% cb$re1$code)) |>
  nrow()
```

Missing or invalid birth sex values.

```{r}
mhsurv |>
  filter(!birth_sex %in% cb$birthsex$code) |>
  nrow()
```

Missing or invalid current gender values.

```{r}
mhsurv |>
  filter(if_all(cg01:cg06, ~ !.x %in% cb$curgen$code)) |>
  nrow()
```

Missing or invalid age values.

```{r}
mhsurv |>
  filter(is.na(age1) | !age1 %in% cb$age1$code) |>
  nrow()
```

Invalid ZIP codes.

```{r}
mhsurv |>
  filter(!zip %in% geoids$zcta$ids2024) |>
  nrow()
```

### Questions

Validate question data against expected values in the codebook.

```{r}
key <- cb$key

vars <- key$var2[!is.na(key$sh_validate)]

ls <- lapply(vars, \(x) {
  sh <- key[which(key$var2 == x), "sh_validate", drop = TRUE]
  vals <- unique(mhsurv[[x]])
  vals[!vals %in% cb[[sh]]$code]
})

names(ls) <- vars
```

Q15: number of hours per day.

```{r}
mhsurv |>
  filter(q15 < 0 | q15 > 24) |>
  nrow()
```

Q17: number of minutes to fall asleep.

```{r}
mhsurv |>
  filter(q17 < 0 | q17 > 1200) |>
  nrow()
```

Q19: sleep duration

```{r}
mhsurv |>
  filter(q19 < 0 | q19 > 24) |>
  nrow()
```

Reversed scale question.

```{r}
mhsurv |>
  select(id, starts_with("q13_")) |>
  bind_cols(n_unq = apply(
    mhsurv |>
      select(starts_with("q13_")),
    1,
    function(x) length(unique(x))
  )) |>
  filter(if_all(starts_with("q13_"), ~ .x %in% 1:5)) |>
  filter(n_unq == 1)
```

Questions 16 and 18 (time of day) validated in scoring section below.

## Configure codebook data

Convert question data to factor.

```{r}
# Factorize as-is
sh <- cb$factors |>
  filter(dir == 1) |>
  pull(factor)

cb[sh] <- lapply(sh, \(x) {
  cb[[x]] |>
    mutate(value = factor(value, levels = value))
})

# Factorize in reverse
sh <- cb$factors |>
  filter(dir == 2) |>
  pull(factor)

cb[sh] <- lapply(sh, \(x) {
  cb[[x]] |>
    mutate(value = factor(value, levels = rev(value)))
})
```

# Reconfigure sample characteristics

## Birth sex

```{r}
mhsurv <- mhsurv |>
  mutate(birth_sex = case_when(
    birth_sex == 1 ~ "Male",
    birth_sex == 2 ~ "Female",
    .default = NA
  )) |>
  mutate(birth_sex = factor(birth_sex, levels = c("Female", "Male")))
```

## Race/ethnicity

Merge separate variables (`re_merge`).

```{r}
# Create list column for race/ethnicity values
mhsurv <- mhsurv |>
  rowwise() |>
  mutate(
    re_code = list(c_across(matches("re\\d"))),
    .after = re_other
  ) |>
  ungroup()

# Remove NAs from lists
mhsurv$re_code <- lapply(mhsurv$re_code, \(x) x[!is.na(x)])

# Replace numbers with text from codebook
mhsurv$re_val1 <- lapply(mhsurv$re_code, \(x) {
  r <- which(cb$re1$code %in% x)
  cb$re1$value[r]
})
mhsurv$re_val2 <- lapply(mhsurv$re_code, \(x) {
  r <- which(cb$re2$code %in% x)
  cb$re2$value[r]
})

# Combine lists into strings
mhsurv$re_merge1 <- lapply(mhsurv$re_val1, \(x) {
 paste(x, collapse = "; ")
})
mhsurv$re_merge2 <- lapply(mhsurv$re_val2, \(x) {
 paste(x, collapse = "; ")
})

# Replace blanks with NA
mhsurv <- mhsurv |>
  rowwise() |>
  mutate(
    re_merge1 = unlist(if_else(
      re_merge1 == "", NA, re_merge1
    )),
    re_merge2 = unlist(if_else(
      re_merge2 == "", NA, re_merge2
    ))
  ) |>
  ungroup() |>
  relocate(
    re_val1, re_merge1,
    re_val2, re_merge2,
    .after = re_code
  )
```

Create collapsed category (`re_bwo`).

- "Black" includes anyone who selected only "African-American/Black" or "African".
- "White" includes anyone who selected only "Middle Eastern or Northern African" or "White/Caucasian".
- "Other" includes anyone who selected another category alone and anyone who selected multiple categories.

```{r}
mhsurv <- mhsurv |>
  mutate(
    re_bwo = case_when(
      grepl("Asian|Hispanic|IndAm|Other|;", re_merge2) ~ "Other",
      grepl("AfAm|African", re_merge2) ~ "Black",
      grepl("MENA|White", re_merge2) ~ "White"
    ),
    .after = re_merge2
  ) |>
  mutate(re_bwo = factor(
    re_bwo,
    levels = c("Black", "White", "Other")
  ))
```

## Hispanic origin

Hispanic origin is a variable created from responses to the race/ethnicity question to align with the Hispanic origin category used by the US Census that is distinct from race.

- "Hispanic" includes anyone who selected "Hispanic/Latinx" alone or in combination with another category.
- "Not Hispanic" includes anyone who did not select "Hispanic/Latinx".

```{r}
mhsurv <- mhsurv |>
  mutate(
    hispanic_origin = if_else(
      re04 == 4, "Hispanic", "Not Hispanic", missing = "Not Hispanic"
    ),
    .after = re_bwo
  ) |>
  mutate(hispanic_origin = factor(
    hispanic_origin,
    levels = c("Hispanic", "Not Hispanic")
  ))
```

## Current gender

Merge separate variables (`cg_merge`).

```{r}
# Create list column for race/ethnicity values
mhsurv <- mhsurv |>
  rowwise() |>
  mutate(
    cg_n = list(c_across(matches("cg\\d"))),
    .after = cg_self_id
  ) |>
  ungroup()

# Remove NAs from lists
mhsurv$cg_n <- lapply(mhsurv$cg_n, \(x) x[!is.na(x)])

# Replace numbers with text from codebook
mhsurv$cg_val <- lapply(mhsurv$cg_n, \(x) {
  r <- which(cb$curgen$code %in% x)
  cb$curgen$value[r]
})

# Combine lists into strings
mhsurv$cg_merge <- lapply(mhsurv$cg_val, \(x) {
 paste(x, collapse = "; ")
})

# Replace blanks with NA
mhsurv <- mhsurv |>
  rowwise() |>
  mutate(cg_merge = unlist(if_else(
    cg_merge == "", NA, cg_merge
  ))) |>
  ungroup() |>
  relocate(cg_val, cg_merge, .after = cg_n)
```

## Age

Duplicate `age1` to use both original (`age1`) and collapsed (`age2`) categories.

```{r}
mhsurv <- mhsurv |>
  mutate(
    age2 = if_else(age1 == 6, 5, age1),
    .after = age1
  )
```

## Lon/lat

Correct longitude and latitude variables, which lack a decimal in the raw data.

```{r}
mhsurv <- mhsurv |>
  mutate(across(c(block_lon, block_lat), ~ .x / 10^6))
```

## ZIP codes

```{r}
mhsurv <- mhsurv |>
  mutate(zip = factor(zip, levels = geoids$zcta$ids2024))
```

## HOI region

Join HOI region variable.

```{r}
surv_rgn <- mhsurv |>
  select(id, block_lon, block_lat) |>
  st_as_sf(coords = c("block_lon", "block_lat"), crs = 4326) |>
  st_join(hoi_regions[, "region"])

mhsurv <- mhsurv |>
  bind_cols(
    surv_rgn |>
      as_tibble() |>
      select(region)
  ) |>
  mutate(region = factor(region, levels = c("North", "Central", "South"))) |>
  relocate(hoi_region = region, .after = block_lat)
```

# Validate MH questions

## Q11: Treatment barriers

Q11 should only be completed if the answer to Q10 is `1` ("Yes").

Count responses to Q10.

```{r}
mhsurv |>
  mutate(code = q10) |>
  group_by(code) |>
  count() |>
  left_join(cb$yn, by = "code") |>
  relocate(value, .after = code)
```

Count rows where Q10 is `1` and any Q11 part is `NA`.

```{r}
mhsurv |>
  filter(q10 == 1) |>
  filter(if_any(q11_01:q11_10, ~ is.na(.x))) |>
  nrow()
```

Count rows where Q10 is not `1` and any Q11 part is not `NA`.

```{r}
mhsurv |>
  filter(q10 != 1) |>
  filter(if_any(q11_01:q11_10, ~ !is.na(.x))) |>
  nrow()
```

## Q13: Social isolation

Count `NA`s.

```{r}
vars <- colnames(mhsurv)[grepl("^q13_\\d", colnames(mhsurv))]

apply(mhsurv[, vars], 2, \(x) sum(is.na(x)))
```

Count "Don't know"s (`9`s).

```{r}
apply(mhsurv[, vars], 2, \(x) sum(ifelse(x == 9, TRUE, FALSE)))
```

Count respondents without any "Don't know"s.

```{r}
mhsurv |>
  filter(!if_any(matches("^q13_\\d"), ~ .x == 9)) |>
  nrow()
```

Plot the number of "Don't know"s per respondent.

```{r}
ls$q13 <- data.frame(n_dontknow = apply(
  mhsurv[, vars], 1, \(x) sum(ifelse(x == 9, TRUE, FALSE))
))

ls$q13$n_answered <- 11 - ls$q13$n_dontknow
```

```{r fig.width=6}
ls$q13 |>
  ggplot(aes(n_dontknow)) +
  geom_histogram(binwidth = 1)
```

## Q14: Social media addiction

Count `NA`s.

```{r}
vars <- colnames(mhsurv)[grepl("^q14_\\d", colnames(mhsurv))]

apply(mhsurv[, vars], 2, \(x) sum(is.na(x)))
```

Count "Don't know"s (`9`s).

```{r}
apply(mhsurv[, vars], 2, \(x) sum(ifelse(x == 9, TRUE, FALSE)))
```

Count respondents without any "Don't know"s.

```{r}
mhsurv |>
  filter(!if_any(matches("^q14_\\d"), ~ .x == 9)) |>
  nrow()
```

Plot the number of "Don't know"s per respondent.

```{r}
ls$q14 <- data.frame(n_dontknow = apply(
  mhsurv[, vars], 1, \(x) sum(ifelse(x == 9, TRUE, FALSE))
))

ls$q14$n_answered <- 6 - ls$q14$n_dontknow
```

```{r fig.width=6}
ls$q14 |>
  ggplot(aes(n_dontknow)) +
  geom_histogram(binwidth = 1)
```

# Score MH questions

## Q8: MH pre/post COVID-19

Group responses to Q8 as "Better", "About the same", or "Worse".

```{r}
mhsurv <- mhsurv |>
  mutate(
    q8a = case_when(
      q8 %in% 1:2 ~ 1, # Better
      q8 == 3     ~ 2, # About the same
      q8 %in% 4:5 ~ 3, # Worse
      .default = NA
    ),
    .after = q8
  )
```

## Q10: Needed but didn't get treatment

Add Q10 result filtered by those who answered "Yes" to Q9 (respondents currently on meds or receiving treatment).

```{r}
mhsurv <- mhsurv |>
  mutate(
    q10a = if_else(q9 == 1, q10, NA),
    .after = q10
  )
```

## Q13: Social isolation

### Validated method

#### Emotional loneliness

Calculate the emotional loneliness score.

> Count the neutral and positive answers ("more or less", "yes", or "yes!") on items 2, 3, 5, 6, 9, 10. This is the emotional loneliness score.

```{r}
vars_emo <- paste0("q13_", sprintf("%02d", c(2, 3, 5, 6, 9, 10)))

mhsurv$si_emo <- mhsurv |>
  select(all_of(vars_emo)) |>
  mutate(across(everything(), ~ if_else(.x %in% 3:5, 1, 0, 0))) |>
  rowSums()
```

Calculate the missing emotional loneliness score.

> Count the missing values (i.e., no answer) on items 2, 3, 5, 6, 9, 10. This is the missing emotional loneliness score.

```{r}
mhsurv$si_emo_missing <- mhsurv |>
  select(all_of(vars_emo)) |>
  mutate(across(everything(), ~ if_else(.x %in% 1:5, 0, 1, 1))) |>
  rowSums()
```

```{r}
df <- mhsurv |>
  select(all_of(vars_emo), starts_with("si_emo"))
```

#### Social loneliness

Calculate the social loneliness score.

> Count the neutral and negative ("no!", "no", or "more or less") answers on items 1, 4, 7, 8, 11. This is the social loneliness score.

```{r}
vars_soc <- paste0("q13_", sprintf("%02d", c(1, 4, 7, 8, 11)))

mhsurv$si_soc <- mhsurv |>
  select(all_of(vars_soc)) |>
  mutate(across(everything(), ~ if_else(.x %in% 1:3, 1, 0, 0))) |>
  rowSums()
```

Calculate the missing social loneliness score.

> Count the missing values (i.e., no answer) on items 1, 4, 7, 8, 11. This is the missing social loneliness score.

```{r}
mhsurv$si_soc_missing <- mhsurv |>
  select(all_of(vars_soc)) |>
  mutate(across(everything(), ~ if_else(.x %in% 1:5, 0, 1, 1))) |>
  rowSums()
```

```{r}
df <- mhsurv |>
  select(all_of(vars_soc), starts_with("si_soc"))
```

#### Total loneliness

Calculate the total loneliness score.

> Compute the total loneliness score by taking the sum of the emotional loneliness score and the social loneliness score.

```{r}
mhsurv$si_total <- mhsurv$si_emo + mhsurv$si_soc
```

#### Drop invalid scores

> The emotional loneliness score is valid only if the missing emotional loneliness score equals 0.
The social loneliness score is valid only if the missing social loneliness score equals 0.
The total loneliness score is valid only if the sum of the missing emotional loneliness score and the missing social loneliness score equals 0 or 1.

```{r}
mhsurv <- mhsurv |>
  mutate(
    si_emo = if_else(si_emo_missing == 0, si_emo, NA),
    si_soc = if_else(si_soc_missing == 0, si_soc, NA),
    si_total = if_else((si_emo_missing + si_soc_missing) %in% 0:1, si_total, NA)
  )
```

#### Binned score

> If desired, the total loneliness score can be categorized into four levels: not lonely (score 0, 1 or 2), moderate lonely (score 3 through 8), severe lonely (score 9 or 10), and very severe lonely (score 11).

```{r}
mhsurv <- mhsurv |>
  mutate(si_total_bin = case_when(
    si_total %in% 0:2 ~ "Not lonely",
    si_total %in% 3:8 ~ "Moderate lonely",
    si_total %in% 9:10 ~ "Severe lonely",
    si_total == 11 ~ "Very severe lonely"
  ))
```

```{r}
df <- mhsurv |>
  select(matches("^q13_|^si_"))
```

### Original method

Reverse scale for questions 01, 04, 07, 08, and 11 so that `1` represents low social isolation and `5` represents high social isolation.

```{r}
mhsurv <- mhsurv |>
  mutate(across(
    c(q13_01, q13_04, q13_07, q13_08, q13_11),
    ~ case_when(
      .x == 1 ~ 5,
      .x == 2 ~ 4,
      .x == 4 ~ 2,
      .x == 5 ~ 1,
      .default = .x
    )
  ))
```

Sum the responses to each part to calculate a composite social isolation score.

```{r}
vars <- colnames(mhsurv)[grepl("^q13_\\d", colnames(mhsurv))]

mhsurv$si_comp <- rowSums(mhsurv[, vars])
```

Drop scores in rows with any "Don't know"s.

```{r}
mhsurv <- mhsurv |>
  mutate(si_comp = if_else(
    if_any(matches("^q13_\\d"), ~ .x == 9),
    NA,
    si_comp
  ))
```

Plot scores.

```{r}
mhsurv |>
  drop_na(si_comp) |>
  ggplot() +
  geom_histogram(aes(si_comp), binwidth = 1)
```

Bin values into low, medium, and high categories. Factorize raw scores.

```{r}
mhsurv <- mhsurv |>
  mutate(si_bin = cut(
    si_comp, breaks = 3, labels = c("Low", "Medium", "High")
  )) |>
  mutate(si_fac = factor(si_comp, levels = minmax_seq(si_comp))) |>
  relocate(si_comp, si_fac, si_bin, .after = q13_11)
```

## Q14: Social media addiction

Sum the responses to each part to calculate a composite social media addiction score.

```{r}
vars <- colnames(mhsurv)[grepl("^q14_\\d", colnames(mhsurv))]

mhsurv$sm_comp <- rowSums(mhsurv[, vars])
```

Drop scores in rows with any "Don't know"s.

```{r}
mhsurv <- mhsurv |>
  mutate(sm_comp = if_else(
    if_any(matches("^q14_\\d"), ~ .x == 9),
    NA,
    sm_comp
  ))
```

Plot scores.

```{r}
mhsurv |>
  drop_na(sm_comp) |>
  ggplot() +
  geom_histogram(aes(sm_comp), binwidth = 1)
```

Bin values into low, medium, and high categories. Factorize raw scores.

```{r}
mhsurv <- mhsurv |>
  mutate(sm_add_bin = cut(
    sm_comp, breaks = 3, labels = c("Low", "Medium", "High")
  )) |>
  mutate(sm_add_fac = factor(sm_comp, levels = minmax_seq(sm_comp))) |>
  relocate(sm_comp, sm_add_fac, sm_add_bin, .after = q14_6)
```

## Q15: Social media use

Factorize and bin.

```{r}
mhsurv <- mhsurv |>
  mutate(
    sm_use_fac = factor(q15, levels = minmax_seq(q15)),
    sm_use_bin = case_when(
      q15 == 0             ~ 1,
      q15 >= 1 & q15 <= 4  ~ 2,
      q15 >= 5 & q15 <= 8  ~ 3,
      q15 >  8 & q15 <= 24 ~ 4,
      .default = NA
    ),
    .after = q15
  )
```

## Q16/18/19: Habitual sleep efficiency

Convert time variables to HH:MM format.

```{r}
mhsurv <- mhsurv |>
  mutate(bed1 = number_to_time(q16), .after = q16) |>
  mutate(wake1 = number_to_time(q18), .after = q18)
```

Validate times.

```{r}
mhsurv |>
  mutate(
    val_bed = validate_time(bed1),
    val_wake = validate_time(wake1),
    .after = wake1
  ) |>
  filter(!val_bed | !val_wake) |>
  select(q16, bed1, q18, wake1, val_bed, val_wake)
```

Convert bed time and wake time pairs to date objects.

```{r}
ls <- times_to_dates(mhsurv$bed1, mhsurv$wake1)
names(ls) <- c("bed2", "wake2")

mhsurv <- mhsurv |>
  bind_cols(ls) |>
  relocate(bed2, .after = bed1) |>
  relocate(wake2, .after = wake1)
```

Validate times (relative to one another).

```{r}
mhsurv |>
  mutate(validate = as.numeric(difftime(wake2, bed2))) |>
  select(id, validate) |>
  filter(validate < 0)
```

Calculate the number of hours spent in bed.

```{r}
mhsurv$hrs_in_bed <- as.numeric(
  difftime(mhsurv$wake2, mhsurv$bed2, "hours")
)
```

Validate `hrs_in_bed`.

```{r}
any(mhsurv$hrs_in_bed < 0, na.rm = TRUE)
```

Calculate PSQI Component 4: Habitual sleep efficiency.

```{r}
mhsurv <- mhsurv |>
  mutate(hse_pct = q19 / hrs_in_bed * 100) |>
  mutate(hse_scored = score_hse(hse_pct)) |>
  relocate(hrs_in_bed, hse_pct, hse_scored, .after = wake2)
```

View percentages > 100.

```{r}
mhsurv |>
  filter(hse_pct > 100) |>
  select(q16:hse_scored)
```

Filter out percentages > 100.

```{r}
mhsurv <- mhsurv |>
  mutate(hse = if_else(hse_pct > 100, NA, hse_scored))
```

## Q19: Sleep duration

```{r}
mhsurv <- mhsurv |>
  mutate(
    slp_dur_fac = factor(q19, levels = minmax_seq(q19)),
    .after = q19
  )
```

# Select data for analysis

```{r}
mhsurv <- mhsurv |>
  rename(
    re_full = re_merge1,
    re_abbr = re_merge2,
    cg = cg_merge,
    si_emo_num = si_emo,
    si_soc_num = si_soc,
    si_total_num = si_total,
    si_num = si_comp,
    sm_add_num = sm_comp,
    sm_use_num = q15,
    slp_lat = q17,
    slp_dur_num = q19
  )
```

```{r}
vars <- key$var2[key$in_final]

mhsurv <- mhsurv |>
  select(all_of(vars))
```

# Recode selected variables

Get pre-replacement column order.

```{r}
cols <- list()
cols[[1]] <- sort(colnames(mhsurv))
```

Recode.

```{r}
vars <- key$var2[!is.na(key$sh_recode)]

ls <- lapply(vars, \(x) {
  sh <- key$sh_recode[which(key$var2 == x)]
  vals <- setNames(cb[[sh]]$value, cb[[sh]]$code)
  unname(vals[mhsurv[[x]]])
})

ls <- as.data.frame(ls, col.names = vars)
```

Replace original columns in `mhsurv`.

```{r}
mhsurv <- cbind(mhsurv[, !colnames(mhsurv) %in% vars], ls)
```

Reorder columns.

```{r}
vars <- c(
  key$var2[which(key$group == "demo")],
  key$var2[which(key$group == "geo")],
  key$var2[which(key$group == "mh")]
)

mhsurv <- mhsurv |>
  select(all_of(vars))
```

Get post-replacement column order.

```{r}
cols[[2]] <- sort(colnames(mhsurv))
```

Compare pre- and post-replacement column orders.

```{r}
if (!isTRUE(all.equal(cols[[1]], cols[[2]]))) {
  warning("Columns are unequal after reordering")
}
```

# Save

```{r}
saveRDS(cb, "../data/2-final/mhs_codebook.rds")
saveRDS(mhsurv, "../data/2-final/mh_survey_results.rds")
```
